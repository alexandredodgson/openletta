
**Pré-requis Phase 2 à faire :**
1. Migration SDK (letta-code-sdk → letta-client)
2. Étude des types de messages Letta
3. Design des composants de rendu d'outils
 
Ces tâches peuvent être réalisées maintenant (préparation proactive) ou au moment de démarrer la Phase 2 (approche séquentielle).
# Plan : Préparation Phase 2 - Migration SDK et Préparatifs
 
## Context
 
**Phase 1 d'OpenLetta est complète à 100%**. L'utilisateur souhaite préparer les pré-requis pour la Phase 2 afin de faciliter son démarrage. Ces tâches consistent à migrer de `@letta-ai/letta-code-sdk` vers `@letta-ai/letta-client` pour accéder aux types de messages détaillés (tool_call, tool_return, reasoning) nécessaires au rendu des outils.
 
## Problème à résoudre
 
Le SDK actuel (`letta-code-sdk`) abstrait les tool calls et ne retourne que les messages assistant finaux. Pour la Phase 2, nous devons voir en temps réel quand l'agent exécute Bash, lit des fichiers, ou édite du code. Le `letta-client` expose tous les types de messages du serveur Letta, permettant ce rendu riche.
 
## Approche d'implémentation
 
### 1. Recherche et validation (Task 1)
 
**Objectif**: Comprendre l'API du `@letta-ai/letta-client` et valider qu'il répond à nos besoins.
 
**Actions**:
- Installer `@letta-ai/letta-client` dans une branche de test
- Examiner les types TypeScript pour les messages
- Tester création d'agent et streaming de messages
- Vérifier que les 6 types de messages sont accessibles (user, assistant, reasoning, tool_call, tool_return, usage_statistics)
- Documenter le mécanisme d'authentification (API key ou local server)
- Tester la continuité de conversation multi-turn
- Confirmer que l'exécution des outils est server-side
 
**Questions à répondre**:
- Le client supporte-t-il l'auth local comme le code SDK?
- Les tool returns sont-ils complets dans le stream?
- Comment gérer la continuité de conversation (conversation ID)?
 
### 2. Créer les définitions de types (Task 2)
 
**Nouveau fichier**: `src/types/letta.ts`
 
**Contenu**: Interfaces TypeScript pour tous les types de messages Letta
- `UserMessage`, `AssistantMessage`, `ReasoningMessage`
- `ToolCallMessage` (nom de l'outil, arguments, tool_call_id)
- `ToolReturnMessage` (résultat, status success/error, tool_call_id)
- `UsageStatistics`
- Type union `LettaMessage`
- Interface `LettaSessionWrapper` pour compatibilité backward
 
**Bénéfice**: Centralise les types, facilite la maintenance et la sûreté de type
 
### 3. Migrer useLettaSession.ts (Task 3)
 
**Fichier**: `src/hooks/useLettaSession.ts`
 
**Changements majeurs**:
1. Remplacer imports: `import { Letta } from '@letta-ai/letta-client'`
2. Créer fonction wrapper `createSessionWrapper()` qui:
   - Initialise le client Letta avec API key
   - Expose les mêmes méthodes que l'ancien SDK (send, stream, close)
   - Gère agent creation/resume via `client.agents.create()` ou `client.agents.get()`
   - Retourne un stream avec `client.agents.messages.stream()`
3. Préserver l'API du hook pour ne pas casser les composants
 
**Défis**:
- Session stateful → API stateless (le wrapper simule la session)
- Auth: gérer API key ou local server URL
- Conversation ID: tracking explicite nécessaire
 
### 4. Mettre à jour useStream.ts (Task 4)
 
**Fichier**: `src/hooks/useStream.ts`
 
**Changements**:
- Importer `LettaMessage` de `types/letta.ts`
- Étendre le state pour capturer tous les types:
  ```typescript
  {
    assistantContent: string,
    reasoning: string[],
    toolCalls: ToolCallMessage[],
    toolReturns: ToolReturnMessage[]
  }
  ```
- Switch case dans le stream consumer pour dispatcher selon `msg.message_type`
- Retourner tous les messages collectés (pas seulement le texte final)
 
**Bénéfice**: Permet à App.tsx d'accéder à tous les messages pour rendu futur
 
### 5. Adapter App.tsx (Task 5)
 
**Fichier**: `src/App.tsx`
 
**Changements**:
1. Nouveau type `DisplayMessage`:
   ```typescript
   {
     role: 'user' | 'assistant' | 'system',
     content?: string,
     reasoning?: string,
     toolCalls?: ToolCallMessage[],
     toolReturns?: ToolReturnMessage[]
   }
   ```
2. Dans `handleSubmit()`, après le stream:
   - Grouper les messages par type
   - Extraire assistantContent, reasoning, toolCalls, toolReturns
   - Ajouter à l'historique avec toutes les données
3. Pour l'instant, ChatView affichera seulement le content (Phase 1 compatible)
4. Les données tool sont stockées pour Phase 2
 
**Note**: Aucun changement visuel pour l'utilisateur, mais les données sont capturées
 
### 6. Préparer ChatView.tsx (Task 6)
 
**Fichier**: `src/components/ChatView.tsx`
 
**Changements minimes**:
- Accepter le nouveau type `DisplayMessage`
- Ajouter placeholder pour tool rendering:
  ```typescript
  {msg.toolCalls && msg.toolCalls.length > 0 && (
    <Text dimColor>[{msg.toolCalls.length} tool call(s) - rendering in Phase 2]</Text>
  )}
  ```
 
**Bénéfice**: Confirme visuellement que les tool messages sont capturés
 
### 7. Mettre à jour package.json (Task 7)
 
**Commandes**:
```bash
bun remove @letta-ai/letta-code-sdk
bun add @letta-ai/letta-client
```
 
### 8. Documentation des types de messages (Task 8)
 
**Nouveau fichier**: `docs/MESSAGE_TYPES.md`
 
**Contenu**:
- Vue d'ensemble du flux de messages Letta
- Séquence typique: user → reasoning → tool_call → tool_return → reasoning → assistant → usage_statistics
- Définitions complètes de chaque type
- Exemples réels capturés du stream
- Stratégie de rendu pour Phase 2
 
### 9. Mettre à jour SPEC.md (Task 9)
 
**Fichier**: `SPEC.md`
 
**Ajouts**:
- Section sur la migration du SDK
- Différences clés entre code-sdk et client
- Documentation des types de messages
- Exemples de code avec nouvelle API
 
### 10. Tests et validation (Task 10)
 
**Tests requis**:
1. **Chat basique**: Start app, send message, verify streaming
2. **Multi-turn**: 3+ exchanges, verify context persists
3. **Tool execution**: Prompt agent to run bash, verify tool_call_message and tool_return_message appear
4. **Error handling**: Invalid API key, network timeout, malformed message
5. **Resume**: Quit and restart, verify agent ID and context preserved
 
**Nouveaux fichiers de test**:
- `__tests__/useLettaSession.test.ts`
- `__tests__/useStream.test.ts`
- `__tests__/messageTypes.test.ts`
 
### 11. Mettre à jour la documentation (Task 11)
 
**Fichiers**:
- **ROADMAP.md**: Cocher les pré-requis Phase 2, noter découvertes
- **CLAUDE.md**: Mettre à jour diagramme architecture, documenter auth
- **README.md**: Ajouter setup API key si nécessaire, update quickstart
 
## Design des composants Phase 2 (Préparation)
 
Ces composants ne seront **pas implémentés** maintenant, mais voici le design:
 
### ToolCallCard.tsx
Container générique pour un tool call avec:
- Header: nom de l'outil
- Body: arguments de l'appel
- Footer: status (pending/running/success/error), durée
 
### Composants spécifiques
1. **BashOutput.tsx**: Commande, stdout (ANSI colors préservées), stderr, exit code
2. **FileRead.tsx**: File path, contenu avec syntax highlighting, line numbers
3. **FileDiff.tsx**: Diff unifié ou side-by-side, lignes vertes (add) / rouges (delete)
4. **FileWrite.tsx**: File path, opération (create/overwrite), file size, preview
 
### Intégration
ChatView itérera sur `msg.toolCalls`, match avec `toolReturns` via `tool_call_id`, et rendra `<ToolCallCard />` pour chacun.
 
## Fichiers critiques
 
1. **`src/hooks/useLettaSession.ts`**: Point central de migration, réécrit session logic avec Letta client
2. **`src/hooks/useStream.ts`**: Étendu pour traiter 6 types de messages au lieu de 2
3. **`src/App.tsx`**: Collecte et stocke tool messages pour Phase 2
4. **`src/types/letta.ts`**: Nouveau fichier, définitions TypeScript centralisées
5. **`package.json`**: Swap de dépendance SDK
 
## Vérification
 
**Tests de régression Phase 1**:
- [x] `bun run build` → sans erreurs
- [x] `bun run dev` → TUI se lance
- [x] Envoyer message → réponse streamée
- [x] Multi-turn → conversation fluide
- [x] Quit/restart → agent persiste
 
**Nouveaux tests Phase 2 prep**:
- [x] Tool call message capturé dans le stream
- [x] Tool return message capturé dans le stream
- [x] Reasoning message capturé dans le stream
- [x] DisplayMessage contient toolCalls et toolReturns
- [x] ChatView affiche placeholder pour tools
 
**Documentation**:
- [x] MESSAGE_TYPES.md créé
- [x] SPEC.md mis à jour
- [x] ROADMAP.md coché (pré-requis Phase 2)
- [x] README.md mis à jour si auth change
 
## Risques et mitigations
 
**Risque élevé**:
- **Auth incompatible**: Si letta-client n'a pas d'auth local, users auront besoin d'API key
  - *Mitigation*: Rechercher early, documenter setup clairement
 
**Risque moyen**:
- **API breaking changes**: Nouveau SDK peut être incompatible
  - *Mitigation*: Tester dans branche isolée, plan de rollback
- **Performance**: Stream complet peut être plus lent
  - *Mitigation*: Throttling/batching si nécessaire
 
**Risque faible**:
- **Types incomplets**: Client peut manquer de types TypeScript
  - *Mitigation*: Créer nos propres types (déjà planifié)
 
## Critères de succès
 
**Must have**:
- ✅ App démarre sans erreurs
- ✅ Messages envoyés et réponses reçues
- ✅ Agent persistence fonctionne
- ✅ Multi-turn conversations OK
- ✅ Tool messages capturés dans stream
- ✅ Toute fonctionnalité Phase 1 préservée
- ✅ Documentation à jour
 
**Phase 2 ready**:
- ✅ `tool_call_message` accessible
- ✅ `tool_return_message` accessible
- ✅ `reasoning_message` accessible
- ✅ Structure de message documentée
- ✅ Points d'intégration identifiés